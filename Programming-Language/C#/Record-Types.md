# C# Record Types

## 🔹 What are Record Types in C#?

A record is a reference type introduced in C# 9.0 that provides a concise syntax for immutable data models and enables value-based equality.

Records are ideal for:

- Modeling data  
- Representing value objects (especially in DDD)  
- Creating DTOs, config objects, etc.

## 🔹 Key Features of Records

| Feature                     | Description                                           |
|-----------------------------|-------------------------------------------------------|
| ✅ Value-based equality     | Instances are equal if their values are equal.        |
| ✅ Immutable by design      | Use init for initialization-only properties.          |
| ✅ with expression          | Clone and modify values concisely.                    |
| ✅ Deconstruction support   | Easily extract values.                                |
| ✅ Concise syntax (positional) | Declare data models with fewer lines.             |
| ✅ Auto-generated methods   | Compiler provides Equals, GetHashCode, ToString.      |

## 🔸 Syntax Variants

### Positional Record (Concise)

```
public record Person(string FirstName, string LastName);
```

Automatically creates:

- Immutable properties with init  
- Constructor  
- Equals, GetHashCode, ToString  
- Deconstruct method

### Record with Body (Expanded)

```
public record Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
```

Allows you to add additional members like methods, validation, etc.

### Mutable Record (not recommended unless needed)

```
public record Person
{
    public string FirstName { get; set; } // mutable
    public string LastName { get; set; }
}
```

Still gets value-based equality, but mutability breaks the "immutable by design" philosophy.

## 🔸 Value-Based Equality vs Reference-Based

### ➤ Class Example:

```
public class User
{
    public string Name { get; set; }
}

var u1 = new User { Name = "Alice" };
var u2 = new User { Name = "Alice" };

Console.WriteLine(u1 == u2); // False (different references)
```

### ➤ Record Example:

```
public record User(string Name);

var u1 = new User("Alice");
var u2 = new User("Alice");

Console.WriteLine(u1 == u2); // True (same values)
```

✔️ Records override Equals() and GetHashCode() by default.

## 🔸 The with Expression

```
var p1 = new Person("Alice", "Smith");
var p2 = p1 with { LastName = "Johnson" };

Console.WriteLine(p2); // Person { FirstName = Alice, LastName = Johnson }
```

`with` creates a shallow copy with updated values. Only available for records (not classes).

## 🔸 Deconstruction

Records support tuple-style unpacking:

```
var p = new Person("Alice", "Smith");
var (first, last) = p;

Console.WriteLine(first); // Alice
Console.WriteLine(last);  // Smith
```

## 🔸 ToString() Override

```
var p = new Person("Alice", "Smith");
Console.WriteLine(p.ToString());
// Output: Person { FirstName = Alice, LastName = Smith }
```

Auto-generated by the compiler for better logging/debugging.

## 🔸 Records and Inheritance

Records support inheritance, but it's sealed by default unless explicitly marked `record class`.

```
public record Animal(string Name);
public record Dog(string Name, string Breed) : Animal(Name);
```

⚠️ Caution: Mixing class and record inheritance is not allowed.

## 🔸 Record Structs (C# 10+)

Records can be value types too:

```
public readonly record struct Point(int X, int Y);
```

- ✅ Value type with value equality  
- ✅ Great for lightweight, immutable data containers

## 🔸 Records vs Classes – Side-by-Side Comparison

| Feature          | Class                        | Record                                      |
|------------------|-------------------------------|---------------------------------------------|
| Type             | Reference                     | Reference (or value w/ record struct)       |
| Equality         | Reference-based (==)          | Value-based (== overridden)                 |
| with expression  | ❌ Not supported               | ✅ Yes                                       |
| ToString()       | Default type name             | Auto-generated readable string              |
| Immutability     | Must be manually enforced     | Natural via init                            |
| Deconstruction   | ❌ Manual                      | ✅ Automatic                                 |
| Use case         | Behavior/service modeling     | Data modeling, DTOs                         |

## 🔸 When to Use Records

✅ Use records when:

- You care about value equality  
- You need immutable objects  
- You are working with DTOs/configs  
- You want easy object copying (`with`)  

❌ Use classes when:

- You need mutable state  
- You rely on reference identity  
- You are modeling behaviors or services

## 🔸 Examples

### ✅ Immutable Record

```
public record Order(int OrderId, string Status);
```

### ❌ Mutable Record (use cautiously)

```
public record Order
{
    public int OrderId { get; set; }       // mutable
    public string Status { get; set; }     // mutable
}
```

### ✅ Record with Methods

```
public record Product(string Name, decimal Price)
{
    public decimal GetDiscountedPrice(decimal percent) =>
        Price - (Price * percent / 100);
}
```
