# C# Record Types

## ðŸ”¹ What are Record Types in C#?

A record is a reference type introduced in C# 9.0 that provides a concise syntax for immutable data models and enables value-based equality.

Records are ideal for:

- Modeling data  
- Representing value objects (especially in DDD)  
- Creating DTOs, config objects, etc.

## ðŸ”¹ Key Features of Records

| Feature                     | Description                                           |
|-----------------------------|-------------------------------------------------------|
| âœ… Value-based equality     | Instances are equal if their values are equal.        |
| âœ… Immutable by design      | Use init for initialization-only properties.          |
| âœ… with expression          | Clone and modify values concisely.                    |
| âœ… Deconstruction support   | Easily extract values.                                |
| âœ… Concise syntax (positional) | Declare data models with fewer lines.             |
| âœ… Auto-generated methods   | Compiler provides Equals, GetHashCode, ToString.      |

## ðŸ”¸ Syntax Variants

### Positional Record (Concise)

```
public record Person(string FirstName, string LastName);
```

Automatically creates:

- Immutable properties with init  
- Constructor  
- Equals, GetHashCode, ToString  
- Deconstruct method

### Record with Body (Expanded)

```
public record Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
```

Allows you to add additional members like methods, validation, etc.

### Mutable Record (not recommended unless needed)

```
public record Person
{
    public string FirstName { get; set; } // mutable
    public string LastName { get; set; }
}
```

Still gets value-based equality, but mutability breaks the "immutable by design" philosophy.

## ðŸ”¸ Value-Based Equality vs Reference-Based

### âž¤ Class Example:

```
public class User
{
    public string Name { get; set; }
}

var u1 = new User { Name = "Alice" };
var u2 = new User { Name = "Alice" };

Console.WriteLine(u1 == u2); // False (different references)
```

### âž¤ Record Example:

```
public record User(string Name);

var u1 = new User("Alice");
var u2 = new User("Alice");

Console.WriteLine(u1 == u2); // True (same values)
```

âœ”ï¸ Records override Equals() and GetHashCode() by default.

## ðŸ”¸ The with Expression

```
var p1 = new Person("Alice", "Smith");
var p2 = p1 with { LastName = "Johnson" };

Console.WriteLine(p2); // Person { FirstName = Alice, LastName = Johnson }
```

`with` creates a shallow copy with updated values. Only available for records (not classes).

## ðŸ”¸ Deconstruction

Records support tuple-style unpacking:

```
var p = new Person("Alice", "Smith");
var (first, last) = p;

Console.WriteLine(first); // Alice
Console.WriteLine(last);  // Smith
```

## ðŸ”¸ ToString() Override

```
var p = new Person("Alice", "Smith");
Console.WriteLine(p.ToString());
// Output: Person { FirstName = Alice, LastName = Smith }
```

Auto-generated by the compiler for better logging/debugging.

## ðŸ”¸ Records and Inheritance

Records support inheritance, but it's sealed by default unless explicitly marked `record class`.

```
public record Animal(string Name);
public record Dog(string Name, string Breed) : Animal(Name);
```

âš ï¸ Caution: Mixing class and record inheritance is not allowed.

## ðŸ”¸ Record Structs (C# 10+)

Records can be value types too:

```
public readonly record struct Point(int X, int Y);
```

- âœ… Value type with value equality  
- âœ… Great for lightweight, immutable data containers

## ðŸ”¸ Records vs Classes â€“ Side-by-Side Comparison

| Feature          | Class                        | Record                                      |
|------------------|-------------------------------|---------------------------------------------|
| Type             | Reference                     | Reference (or value w/ record struct)       |
| Equality         | Reference-based (==)          | Value-based (== overridden)                 |
| with expression  | âŒ Not supported               | âœ… Yes                                       |
| ToString()       | Default type name             | Auto-generated readable string              |
| Immutability     | Must be manually enforced     | Natural via init                            |
| Deconstruction   | âŒ Manual                      | âœ… Automatic                                 |
| Use case         | Behavior/service modeling     | Data modeling, DTOs                         |

## ðŸ”¸ When to Use Records

âœ… Use records when:

- You care about value equality  
- You need immutable objects  
- You are working with DTOs/configs  
- You want easy object copying (`with`)  

âŒ Use classes when:

- You need mutable state  
- You rely on reference identity  
- You are modeling behaviors or services

## ðŸ”¸ Examples

### âœ… Immutable Record

```
public record Order(int OrderId, string Status);
```

### âŒ Mutable Record (use cautiously)

```
public record Order
{
    public int OrderId { get; set; }       // mutable
    public string Status { get; set; }     // mutable
}
```

### âœ… Record with Methods

```
public record Product(string Name, decimal Price)
{
    public decimal GetDiscountedPrice(decimal percent) =>
        Price - (Price * percent / 100);
}
```
